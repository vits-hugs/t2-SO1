se n usar um new pode chamar um destrutor.



 db<Thread>(TRC) << "dispatcher dispatchando\n";
    //Equanto houver mais de 2 threads, pois tem a main e a disaptcher

    while (true) {
    //escolha a prÃ³xima
    
    auto ponteiro = _ready.head();
    Thread * next = ponteiro->object();
    
   _dispatcher._state = READY;

    int now = (std::chrono::duration_cast<std::chrono::microseconds>
(std::chrono::high_resolution_clock::now().time_since_epoch()).count());
   //_ready.remove(&_dispatcher._link);
   _dispatcher._link.rank(now);
   _ready.insert(&_dispatcher._link);
   _running = next;
   next->_state = RUNNING;
   Thread::switch_context(&_dispatcher,next);
    if (_ready.head()->object()->_state == FINISHING) {
        _ready.remove_head();
    }

    }
   
    db<Thread>(TRC) << "Dispatcher sendo finalizada e indo pro main";
    _dispatcher._state = FINISHING;
    _ready.remove(&_dispatcher._link);
    Thread::switch_context(&_dispatcher,&_main);